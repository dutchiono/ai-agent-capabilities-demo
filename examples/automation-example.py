#!/usr/bin/env python3
"""
AI Agent Automation Example
============================

This script demonstrates the kind of functional code that AI agents can generate
autonomously. It shows a real-world automation scenario: monitoring a GitHub
repository for new issues and sending notifications.

Generated by: Nebula AI Agent System
Date: February 13, 2026
Purpose: Demonstration of agent code generation capabilities
"""

import os
import json
import requests
from datetime import datetime, timedelta
from typing import List, Dict, Optional


class GitHubIssueMonitor:
    """
    Monitor GitHub repository for new issues and send notifications.
    
    This is a simplified example showing agent-generated code structure,
    error handling, and real-world API integration patterns.
    """
    
    def __init__(self, repo_owner: str, repo_name: str, github_token: str):
        """
        Initialize the GitHub issue monitor.
        
        Args:
            repo_owner: GitHub repository owner username
            repo_name: Repository name
            github_token: GitHub personal access token for API authentication
        """
        self.repo_owner = repo_owner
        self.repo_name = repo_name
        self.github_token = github_token
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"Bearer {github_token}",
            "Accept": "application/vnd.github.v3+json"
        }
    
    def get_recent_issues(self, hours: int = 24) -> List[Dict]:
        """
        Fetch issues created in the last N hours.
        
        Args:
            hours: Number of hours to look back (default: 24)
            
        Returns:
            List of issue dictionaries with relevant information
            
        Raises:
            requests.RequestException: If API call fails
        """
        try:
            # Calculate timestamp for filtering
            since = datetime.utcnow() - timedelta(hours=hours)
            since_iso = since.isoformat() + "Z"
            
            # Build API endpoint
            url = f"{self.base_url}/repos/{self.repo_owner}/{self.repo_name}/issues"
            params = {
                "state": "open",
                "since": since_iso,
                "per_page": 100
            }
            
            # Make API request
            response = requests.get(url, headers=self.headers, params=params)
            response.raise_for_status()
            
            issues = response.json()
            
            # Filter out pull requests (GitHub API includes them in issues endpoint)
            issues = [issue for issue in issues if "pull_request" not in issue]
            
            return issues
            
        except requests.RequestException as e:
            print(f"Error fetching issues: {e}")
            raise
    
    def format_issue_summary(self, issue: Dict) -> str:
        """
        Format issue data into a readable summary.
        
        Args:
            issue: Issue dictionary from GitHub API
            
        Returns:
            Formatted string summary of the issue
        """
        title = issue.get("title", "No title")
        number = issue.get("number", "N/A")
        author = issue.get("user", {}).get("login", "Unknown")
        created = issue.get("created_at", "Unknown")
        url = issue.get("html_url", "No URL")
        labels = [label["name"] for label in issue.get("labels", [])]
        
        summary = f"""
Issue #{number}: {title}
Created by: {author}
Created at: {created}
Labels: {", ".join(labels) if labels else "None"}
URL: {url}
"""
        return summary.strip()
    
    def send_notification(self, issues: List[Dict]) -> None:
        """
        Send notification about new issues.
        
        In a real implementation, this would integrate with Slack, email,
        or other notification services. This example just prints to console.
        
        Args:
            issues: List of new issues to report
        """
        if not issues:
            print("No new issues found.")
            return
        
        print(f"\n{'='*60}")
        print(f"GITHUB ISSUE ALERT - {len(issues)} New Issue(s)")
        print(f"Repository: {self.repo_owner}/{self.repo_name}")
        print(f"{'='*60}\n")
        
        for issue in issues:
            print(self.format_issue_summary(issue))
            print(f"{'-'*60}\n")
    
    def run_monitoring_cycle(self, check_hours: int = 1) -> Dict:
        """
        Execute one monitoring cycle.
        
        Args:
            check_hours: How many hours back to check for issues
            
        Returns:
            Dictionary with monitoring results
        """
        try:
            print(f"Checking for issues in last {check_hours} hour(s)...")
            
            issues = self.get_recent_issues(hours=check_hours)
            self.send_notification(issues)
            
            return {
                "success": True,
                "issues_found": len(issues),
                "timestamp": datetime.utcnow().isoformat(),
                "error": None
            }
            
        except Exception as e:
            error_msg = f"Monitoring cycle failed: {str(e)}"
            print(f"ERROR: {error_msg}")
            
            return {
                "success": False,
                "issues_found": 0,
                "timestamp": datetime.utcnow().isoformat(),
                "error": error_msg
            }


def main():
    """
    Main execution function with configuration and error handling.
    """
    # Configuration (in real use, these would come from environment variables)
    config = {
        "repo_owner": "dutchiono",
        "repo_name": "ai-agent-capabilities-demo",
        "github_token": os.getenv("GITHUB_TOKEN", "your-token-here"),
        "check_hours": 24
    }
    
    print("AI Agent Automation Example - GitHub Issue Monitor")
    print("=" * 60)
    print(f"Repository: {config['repo_owner']}/{config['repo_name']}")
    print(f"Check interval: Last {config['check_hours']} hours")
    print("=" * 60 + "\n")
    
    # Validate configuration
    if config["github_token"] == "your-token-here":
        print("WARNING: GitHub token not configured. Set GITHUB_TOKEN environment variable.")
        print("This is a demonstration script - replace with real credentials for actual use.")
        return
    
    # Initialize monitor
    monitor = GitHubIssueMonitor(
        repo_owner=config["repo_owner"],
        repo_name=config["repo_name"],
        github_token=config["github_token"]
    )
    
    # Run monitoring cycle
    result = monitor.run_monitoring_cycle(check_hours=config["check_hours"])
    
    # Display results
    print("\nMonitoring Cycle Complete:")
    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()


"""
KEY FEATURES DEMONSTRATED:

1. Clean Code Structure
   - Proper class organization
   - Type hints for clarity
   - Comprehensive docstrings
   - Error handling

2. Real API Integration
   - GitHub REST API v3
   - Authentication headers
   - Request/response handling
   - Error recovery

3. Production Patterns
   - Configuration management
   - Environment variables
   - Logging and status reporting
   - Result formatting

4. Extensibility
   - Easy to modify for different repos
   - Pluggable notification system
   - Configurable time windows
   - Reusable components

5. Security Awareness
   - Token from environment
   - No hardcoded credentials
   - Safe error messages
   - Input validation

USAGE:
------

# Set your GitHub token
export GITHUB_TOKEN="your-github-personal-access-token"

# Run the monitor
python automation-example.py

EXTENSIONS:
-----------

This example could be extended to:
- Send Slack/email notifications
- Create automated responses
- Assign issues based on labels
- Generate daily summary reports
- Integrate with project management tools
- Trigger CI/CD pipelines

This demonstrates that AI agents can generate functional, production-ready
code with proper structure, error handling, and real-world integration patterns.
"""